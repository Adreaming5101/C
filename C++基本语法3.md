## 数组

### 1.数组的定义

```c++
数组概念：
    集合；有序；存放数据类型相同(不能存放整数，又存放小数)

定义数组：
    类型说明符 数组名[常量表达式]    // 类型说明符说明数组的类型，可以是任一种基本数据类型或构造数据类型
// 数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同的。
// 方括号中的常量表达式表示数据元素的个数，也称为数组的长度；不能在方括号中用变量来表示元素的个数。
    
// 特殊的数组
    char str[20] = "hello world"  //在C语言中，字符串通常是以字符数组的形式存储的，而字符数组是一种连续的内存序列
    
// 为什么字符串以\0(null,ASCII码为0的空字符作为字符串的结束标志。)结尾？：
    /*
    1.字符串长度的存储：没有内建的字符串类型，而是使用字符数组来表示字符串。以null结尾《编译器》可以轻松确定字符串的长度（扫描字符数组，直到遇到null字符，就能确定字符串的结束位置。）
    
    2.兼容性：使用null结尾的字符串是一种简单而有效的表示方式，它与C语言的字符数组和指针等基本概念兼容。这也是为什么C标准库中的许多字符串处理函数（如strlen、strcpy等）都依赖于字符串以null结尾的约定。
    
    3.易于处理： 以null结尾的字符串使得在C中进行字符串操作更加方便。例如，通过循环遍历字符数组，可以轻松地执行字符串拷贝、连接、比较等操作。
    */
    

例子：
    #include <stdio.h>
    int main() {
        char myString[] = "Hello";     // *******只允许在定义的时候初始化*******
        for (int i = 0; i < 5; i++) {
            printf("%c\n", myString[i]);
        }
    }
    

#include <stdio.h>
int main() {
    char myString_1[] = "Hello";     // *******只允许在定义的时候初始化*******
    char myString_2[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    char myString_3[10] = {'H', 'e', 'l', 'l', 'o', '\0'};
    for (int i = 0; i < 5; i++) {
        printf("%c\n", myString_1[i]);
    }
}


char str = "hello"      // ********C语言不能直接定义字符串，需要使用数组来定义********
char str[] = "hello"    // 正确写法
char str = "h";         // 错误写法，字符用单引号
char st = 'h';          // 正确写法

// 数组定义char myString_2[] 与 char myString_3[10] 的区别：
    char myString_2[] = {'H', 'e', 'l', 'l', 'o', '\0'};  // 编译器自动动态确定数组大小，定义时无需关心数组长度大小，非常灵活

    char myString_3[10] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 显示指定数组大小为10，若长度大于字符串大小会浪费一些内存
    
    
// 错误写法:
	char str[10];
	char str[10] = {'h','e','l','l','o','/0'};
```

**数组与变量区别**

![avatar](picture\变量与数组.png)

### 2.二维数组

```c++
int array[3]; ------------>int [3] 看作是一维数组类型

int array[3][3] = {{1,1,1},{2,2,2},{3,3,3}}; -------->int [3][3] 看作是二维数组类型，第一个[3]表示行，第二个[3]表示列。
 
```

**二维数组的定义：**

![avatar](picture\二维数组定义.png)

将二维数组看作是一个二维表，索引访问到具体元素(外层是行，里层是列)，下面是三行四列的二维表访问的索引：

![avatar](picture\二维数组访问索引.png)



**二维数组的初始化：**

![avatar](picture\二维数组的初始化.png)

```c++

为什么能够这样初始化：
    int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
	// 因为实际上二维数组再内存中是连续的空间

	/*
	C语言中的二维数组在内存中是按照行优先存储的。也就是说，数组元素的存储顺序是按行从左到右依次存储的。数组a是一个3行4列的二维数组。在提供初始值时，C语言会按照行的顺序，依次将值赋给数组元素。
	*/
	
	// 具体来说，上述初始化语句的赋值过程如下：
		a[0][0] = 1
        a[0][1] = 2
        a[0][2] = 3
        a[0][3] = 4
        a[1][0] = 5
        a[1][1] = 6
        a[1][2] = 7
        a[1][3] = 8
        a[2][0] = 9
        a[2][1] = 10
        a[2][2] = 11
        a[2][3] = 12
    // 通过一维数组的初始化方式，可以方便地初始化二维数组。在这个例子中，初始值的顺序与数组元素在内存中的存储顺序一致，因此可以简洁地完成初始化。
	
```



**二维数组的赋值：**

![avatar](picture\二维数组的赋值.png)



**二维数组的访问：**

![avatar](picture\二维数组的访问.png)



### 3.二维数组内存结构

```c++
// 验证二维数组内存是连续的
#include <stdio.h>
int main () {
    int a = 10;
    printf("%p\n", &a);     // %p 指针占位符----地址， &取址符

    int array1[3][3] = {1,2,3,4,5,6,7,8, 9};
    //遍历二维数组
    for (int i = 0; i < 3; i++) {     // 遍历行
        for (int j = 0; j < 3; j++) {    // 遍历当前行的每一列
            printf("%p ", &array1[i][j]);

        }
    }

}
/*
打印结果，连续的内存空间，间隔4个字节：
000000832c1ff800 000000832c1ff804 000000832c1ff808 000000832c1ff80c 000000832c1ff810 000000832c1ff814 000000832c1ff818 000000832c1ff81c 000000832c1ff820 
一个整数占4个字节

基本思想：
二维数组，引入二维表格的思想来理解
*/

例题2：
/*
 *矩阵加法：定义两个大小相同的二维数组，并初始化。分别输出两个二维数组的值，以及两个数组相同位置上的值相加以后的结果。
 */
#include <stdio.h>
int main () {
    int array1[2][3] = {1,2,3,4,5,6};
    int array2[2][3] = {10,20,30,40,50,60};
    for (int i = 0; i < 2; i++) {     // i < 2 因为只有两行
        for (int j = 0; j < 3; j++) {   // j < 3 因为每行只有三列
            printf("%d + %d = %d", array1[i][j], array2[i][j], array1[i][j] + array2[i][j]);
        }
        putchar('\n');       // 用于输出换行符（newline）的语句。二维数组第一行执行完毕并打印，再换行，打印第二行，输出易读性
    }
}
/*
思想：结构相同，依据索引取值，只是取值对应不同，索引都一样
*/

// ************重点思想***************
/*
二维数组名字是整个二维数组内存起始地址，也是二维数组中第一个子数组内存起始地址--------->也就是说二维数组名是一个地址，是第一个子数组的起始地址，第一个子数组的起始地址指向的是第一个元素地址
*/


```

## 字符串

### 1.字符串的定义与初始化

```c++
![字符串相关](G:\C++\picture\字符串相关.png)![字符串的定义与初始化](G:\C++\picture\字符串的定义与初始化.png)char ch = 'A';    // 正确写法，单引号包含一个字符
char ch = "A";	  // 错误写法，双引号包含字符串
/*
**********重要思想：*********
整型变量也可存放字符，按照ASCII；那么整型数组也可存储字符串，但是一个整数占4个字节，而一个字符占1个字节，所以还是得用字符数组来存放字符串，节约资源

C语言中没有字符串类型的变量，只有字符型变量，可以使用字符数组来存放字符串
*/


案例1：
    #include <stdio.h>
    int main() {
        char sz[] = {'C','h','i','n','a'};     // 没有\0结尾，一共5个字符
        char sz1[] = "China";    // 有\0结尾，一共6个字符
        printf("sz[]:%ld, sz1[]:%ld", sizeof(sz), sizeof(sz1));   // sizeof用于获取对象或类型的占用内存大小，sizeof 返回的结果是 size_t 类型，而 size_t 类型在一些系统中可能是 unsigned long 类型，因此使用 %ld 来格式化这个值是正确的。

    }

案例2：
    #include <stdio.h>
    int main() {
        char s[] = "";
        printf("%ld", sizeof s); // 长度为1，""为空字符串，包含一个\0

    }

案例3：
 /*
 * 求字符数组的长度
 * */
#include <stdio.h>
int main() {
    char str1[] = {'1', '2', '3', '4', '5', '6', '7', '8', '\0'};    // 这种字符串初始化一定要以\0结尾
    int index = 0;
    while (str1[index] != '\0') {
        printf("%c ", str1[index++]);  // 若改成 str1[++index]，将先自加，再打印数组值，那么第一个元素不会打印，先自加则直接从第二个元素开始
    }
    printf("%d", index);
}
    
```

![avatar](picture\字符串相关.png)

**字符串的初始化**

![avatar](picture\字符串的定义与初始化.png)



### 2.字符串函数操作

```c++
#include <string.h>    // 字符串操作相关的系统库，存放了一些【字符串】操作函数，这些函数遵循\0结尾的规则，所以字符串最好以\0结尾

// ---------------------------《1.memset() 函数》------------------------------------
	用于将一段内存区域的每个字节都设置为特定的值。它的声明如下：
        void *memset(void *s, int c, size_t n);
		s：指向要设置的内存区域的指针。
		c：要设置的值，通常是一个字符。
		n：要设置的字节数。
	
    ******************memset 主要用于初始化或清零内存区域。*************************       
案例1(清零数组)：
	#include <stdio.h>
    #include <string.h>
    int main() {
        char sz[] = {'C', 'h', 'i', 'n', 'a', '\0'};
        char sz1[] = "China";
        printf("%s\n", sz);
        memset(sz, '\0', 10);         // 前10个字节都设置为\0
        printf("%ld", sizeof(sz));    // 6
    }
	/*
	**********重点思想：为什么清理了打印字节长度还是6？*************
	使用 memset 函数将数组 sz 的前10个字节都设置为 '\0'（空字符）。然而，这并不影响数组的大小。	数组的大小由其声明时的元素数量决定，而不受 memset 的影响。sizeof(sz) 返回的是数组 sz 的总字节数，所以仍然是6
	*/
	
案例2(清零数组)：
    #include <stdio.h>
    #include <string.h>
    int main() {
        int arr[5];
        memset(arr, 0, sizeof(arr));      // 用0替换

        // 数组被清零
        for (int i = 0; i < 5; i++) {
            printf("%d ", arr[i]); // 输出 0 0 0 0 0
        }

        return 0;
    }

案例3(初始化数组)：
    #include <stdio.h>
    #include <string.h>

    int main() {
        char str[10];         // 全是\0
        memset(str, 'A', 5);  // 用A替换

        // 字符数组被初始化为 'A'
        printf("%s\n", str); // 输出 AAAAA

        return 0;
    }
案例4(清零结构体)：
    #include <stdio.h>
    #include <string.h>

    struct Example {
        int x;
        double y;
    };

    int main() {
        struct Example ex;
        memset(&ex, 0, sizeof(ex));

        // 结构体被清零
        printf("%d %lf\n", ex.x, ex.y); // 输出 0 0.000000

        return 0;
    }
案例5(设置特定值)：
    #include <stdio.h>
    #include <string.h>

    int main() {
        char buffer[10];
        memset(buffer, '@', sizeof(buffer));

        // 数组被设置为 '@'
        printf("%s\n", buffer); // 输出 @@@@@@@@@

        return 0;
    }
/*
memset 在以上示例中被用于初始化数组、清零内存或设置特定值。使用场景通常涉及到需要初始化内存区域的情况，例如在数据结构创建时，或者在清理敏感信息的缓冲区时。
*/

// ---------------------------《2.strlen() 函数》------------------------------------
用法：用于计算字符串长度
strlen 函数的声明如下：
	size_t strlen(const char *s);
	/*
	其中：
	s 是一个指向以 null 结尾的字符串的指针。
	返回值是字符串的长度，不包括 null 终止符。
	*/

案例1：
    #include <stdio.h>
    #include <string.h>

    int main() {
        const char *str = "Hello, World!";
        size_t length = strlen(str);

        printf("Length of the string: %zu\n", length);

        return 0;
    }
	/*
	在这个例子中，strlen 函数用于计算字符串 "Hello, World!" 的长度，并将结果存储在 length 变量中。%zu 用于格式化 size_t 类型的值。
	
	使用场景：
		在处理字符串输入时，或者在分配足够内存来存储字符串时。
	*/


```







































































































